/**
 * Alipay.com Inc.
 * Copyright (c) 2004-2018 All Rights Reserved.
 */
package com.ranttu.rapid.reffer.clone;

import com.ranttu.rapid.reffer.misc.$;
import com.ranttu.rapid.reffer.misc.BackdoorObject;
import com.ranttu.rapid.reffer.misc.ObjectUtil;
import com.ranttu.rapid.reffer.misc.StringUtil;
import com.ranttu.rapid.reffer.misc.asm.ClassWriter;
import com.ranttu.rapid.reffer.misc.asm.MethodVisitor;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.experimental.var;
import lombok.val;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_FINAL;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_PRIVATE;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_PUBLIC;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_STATIC;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_SUPER;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_SYNTHETIC;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ACC_TRANSIENT;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ALOAD;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ARETURN;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.ASTORE;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.DUP;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.GETFIELD;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.INVOKEINTERFACE;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.INVOKESPECIAL;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.INVOKESTATIC;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.INVOKEVIRTUAL;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.NEW;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.POP;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.PUTFIELD;
import static com.ranttu.rapid.reffer.misc.asm.Opcodes.V1_6;
import static com.ranttu.rapid.reffer.misc.asm.Type.getDescriptor;
import static com.ranttu.rapid.reffer.misc.asm.Type.getInternalName;

/**
 * auto-gen fast cloner factory
 *
 * @author rapid
 * @version $Id: FastClonerFactory.java, v 0.1 2018-09-20 11:03 PM rapid Exp $
 */
@RequiredArgsConstructor
final public class FastClonerFactory {
    /**
     * clone config
     */
    private final CloneConfig cloneConfig;

    /**
     * generated cloner meta info
     */
    private final Map<Class<?>, GenFCMetaInfo> fcMetaInfos = new IdentityHashMap<>(64);

    /**
     * cached fast cloner classes
     */
    private final Map<String, Class<?>> cachedFastClonerClasses = new HashMap<>(64);

    /**
     * cached fast cloners
     */
    private final Map<String, FastCloner> cachedFastCloners = new WeakHashMap<>(64);

    /**
     * lock
     */
    private final Object CLONER_GEN_LOCK = new Object();

    /**
     * number of clazz generated
     */
    private final static AtomicInteger clazzCount = new AtomicInteger();

    // index of parameters and variables
    private static final int CLM_V_OBJ = 1;          // object to be cloned
    private static final int CLM_V_CLONED = 2;       // cloned objects
    private static final int CLM_V_CL = 3;           // class loader
    private static final int CLM_V_CLONER = 4;       // cloner
    private static final int CLM_V_TARGET_SLOT = 5;  // target object

    /**
     * get or generate a fast cloner
     * <p>
     * this is generated by asm lib, don't use this fastCloner to do other things than clone, or u fucked up
     */
    public FastCloner getFastCloner(Class<?> c, ClassLoader cl) {
        String key = c.hashCode() + "_" + cl.hashCode();

        FastCloner fc;
        if ((fc = cachedFastCloners.get(key)) == null) {
            synchronized (CLONER_GEN_LOCK) {
                if ((fc = cachedFastCloners.get(key)) == null) {
                    fc = genCloner(key, c, cl);
                    cachedFastCloners.put(key, fc);
                }
            }
        }

        return fc;
    }

    /**
     * generate a cloner
     */
    @SneakyThrows
    private FastCloner genCloner(String key, Class<?> c, ClassLoader cl) {
        GenFCMetaInfo fcMetaInfo = fcMetaInfos.computeIfAbsent(c, this::generateClonerMetaInfo);

        Class<?> fcClz = cachedFastClonerClasses.computeIfAbsent(key,
            k -> defineClass(fcMetaInfo.getFcClassName(), cl, fcMetaInfo.getByteCodes()));

        return (FastCloner) $.getUnsafe().allocateInstance(fcClz);
    }

    /**
     * generate a fast cloner
     */
    private GenFCMetaInfo generateClonerMetaInfo(Class<?> clz) {
        // TODO: can use expanded clone

        var fcClzName = generateFcClazzName(clz);
        var fcClzInternalName = fcClzName.replace('.', '/');

        // start define
        var cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        cw.visit(V1_6,
            ACC_SYNTHETIC + ACC_SUPER + ACC_PUBLIC,
            fcClzInternalName,
            null,
            getInternalName(BackdoorObject.class),
            new String[]{getInternalName(FastCloner.class)});
        cw.visitSource("<reffer-generated-cloner>", null);

        //~~~ set configs
        serializeConfigs(cw, clz.getName(), cloneConfig);

        //~~~ clone method
        visitCloneMethod(cw, clz);

        // generate byte code
        cw.visitEnd();

        var bc = cw.toByteArray();
        ObjectUtil.printClass(fcClzName, bc);

        return GenFCMetaInfo.of(clz, fcClzName, bc);
    }

    /**
     * write configs to class
     */
    private void serializeConfigs(ClassWriter cw, String className, CloneConfig cc) {
        if (!cc.isDumpFcInfo()) {
            return;
        }

        Map<String, String> configs = new LinkedHashMap<>();

        configs.put("className", className);
        configs.put("dumpFcInfo", String.valueOf(cc.isDumpFcInfo()));
        configs.put("ignoreTransient", String.valueOf(cc.isIgnoreTransient()));

        for (String configKey : configs.keySet()) {
            String confValue = configs.get(configKey);

            cw.visitField(
                ACC_PRIVATE | ACC_STATIC | ACC_FINAL | ACC_TRANSIENT,
                "$" + configKey, "Ljava/lang/String;",
                null, confValue);
        }
    }

    /**
     * generate the clone method
     */
    private void visitCloneMethod(ClassWriter cw, Class<?> clz) {
        val interClzName = getInternalName(clz);

        var mv = cw.visitMethod(ACC_PUBLIC,
            "clone",
            "(Ljava/lang/Object;"
                + "Ljava/util/Map;"
                + "Ljava/lang/ClassLoader;"
                + "Lcom/ranttu/rapid/reffer/clone/Cloner;"
                + ")Ljava/lang/Object;",
            null,
            null);

        // method content
        mv.visitCode();

        // prepare to add to cloned map
        mv.visitVarInsn(ALOAD, CLM_V_CLONED);
        mv.visitVarInsn(ALOAD, CLM_V_OBJ);

        //~~~ new instance
        mv.visitTypeInsn(NEW, interClzName);
        // use the default constructor if has
        if (ObjectUtil.hasDefaultConstructor(clz)) {
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL, interClzName, "<init>", "()V", false);
        }

        //~~~ after call constructor, update "cloned map"
        mv.visitInsn(DUP);
        mv.visitVarInsn(ASTORE, CLM_V_TARGET_SLOT);
        mv.visitMethodInsn(INVOKEINTERFACE,
            getInternalName(Map.class), "put",
            "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", true);
        mv.visitInsn(POP);
        mv.visitVarInsn(ALOAD, CLM_V_TARGET_SLOT);

        //~~~ set fields
        Set<String> visitedFieldNames = new HashSet<>();
        for (Field f : ObjectUtil.getAllFields(clz)) {
            // for same name fields, we only clone the very sub class field
            if (visitedFieldNames.contains(f.getName())) {
                return;
            }

            // don't clone static field
            if (Modifier.isStatic(f.getModifiers())) {
                continue;
            }

            // ignore transient field on need
            if (cloneConfig.isIgnoreTransient() && Modifier.isTransient(f.getModifiers())) {
                continue;
            }

            var fieldClz = f.getType();

            // as visited
            visitedFieldNames.add(f.getName());

            // copy field
            mv.visitInsn(DUP);

            // copy to final fields: prepare
            if (Modifier.isFinal(f.getModifiers())) {
                // push offset on stack
                // NOTE: must not be static field
                long fieldOffset = $.getUnsafe().objectFieldOffset(f);
                mv.visitLdcInsn(fieldOffset);
            }

            // for primitive field, copy directly
            if (cloneConfig.shouldIgnore(fieldClz)) {
                mv.visitVarInsn(ALOAD, CLM_V_OBJ);
                mv.visitFieldInsn(GETFIELD, interClzName, f.getName(), getDescriptor(fieldClz));
            }
            // other field, use cloner's copy
            else {
                mv.visitVarInsn(ALOAD, CLM_V_CLONER);

                // obj.field
                mv.visitVarInsn(ALOAD, CLM_V_OBJ);
                mv.visitFieldInsn(GETFIELD, interClzName, f.getName(), getDescriptor(fieldClz));

                mv.visitVarInsn(ALOAD, CLM_V_CLONED);
                mv.visitVarInsn(ALOAD, CLM_V_CL);

                mv.visitMethodInsn(
                    INVOKEVIRTUAL,
                    getInternalName(Cloner.class),
                    "cloneInternal",
                    "(Ljava/lang/Object;Ljava/util/Map;Ljava/lang/ClassLoader;)Ljava/lang/Object;",
                    false);
            }

            // common field set
            if (!Modifier.isFinal(f.getModifiers())) {
                mv.visitFieldInsn(PUTFIELD, interClzName, f.getName(), getDescriptor(fieldClz));
            }
            // final field set
            else {
                handleFinalFieldSet(mv, f);
            }
        }

        //~~~ return clone target
        mv.visitInsn(DUP);
        mv.visitInsn(ARETURN);

        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }

    /**
     * set to final field with unsafe methods
     */
    private void handleFinalFieldSet(MethodVisitor mv, Field f) {
        if (f.getType().isPrimitive()) {
            String methodName = "set" + StringUtil.capFirst(f.getType().getName());
            String methodDesc = "(Ljava/lang/Object;J" + getDescriptor(f.getType()) + ")V";

            mv.visitMethodInsn(INVOKESTATIC, getInternalName(BackdoorObject.class), methodName, methodDesc, false);
        } else {
            mv.visitMethodInsn(INVOKESTATIC, getInternalName(BackdoorObject.class), "setObject",
                "(Ljava/lang/Object;JLjava/lang/Object;)V", false);
        }
    }

    /**
     * generate fc clazz name
     */
    private String generateFcClazzName(Class<?> clz) {
        return "com.ranttu.rapid.reffer.clone.GENFC_" + clz.getSimpleName() + "$" + clazzCount.getAndIncrement();
    }

    /**
     * define the fast cloner class
     */
    private Class<?> defineClass(String className, ClassLoader cl, byte[] byteCodes) {
        return $.getUnsafe().defineClass(
            className, byteCodes, 0, byteCodes.length, cl, null);
    }
}